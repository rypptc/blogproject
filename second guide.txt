Part 1

create virtual env

pip upgrade

install django

startproject (with dot)


Part 2


startapp (in this case blog)

create views

def home(request):
	return render(request, 'blog/home.html')

def about(request):
	return render(request, 'blog/about.html')

create urls.py in app

from django.urls import path
from . import views

urlpatterns = [
	path('', views.home, name='blog-home'),
	path('about'/, views.about, name='blog-about'),
]

urls.py in project

import include

add following path

path('', include('blog.urls')), 

include blog in INSTALLED_APPS


Part 3

templates

copy templates from vscode

base.html, home.html, about.html

include bootstrap on base.html

include navegation bar on base.html

include main on base.html, this includes main section and side bar

create static folder on blog app static/blog

include file main.css

include main.css link, include load static, this is in base.html

in home.html include article.html

change urls to dynamic urls in the templates


Part 4

admin page

makemigrations

migrate

createsuperuser

Part 5

in blog app open models.py

from django.db import models
from django.utils import timezone
from django.contrib.auth.models import User

class Post(models.Model):
	title = modles.CharField(max_length=100)
	content = models.TextField()
	date_posted = models.DateTimeField(default=timezone.now)
	author = models.ForeignKey(User, on_delete=models.CASCADE)

	def __str__(self):
		return self.title

makemigrations

migrate

(tip: python manage.py sqlmigrate bog 0001)

queries in the shell

user.post_set.all()

when creating user.post_set.create, no need to save 

date filter

{{ post.date_posted|date:"F d, Y" }}, revise django documentation date filter

include Post model on the admin


Part 6


create registration page

startapp users

include app in INSTALLED_APPS

create register view

from django.contrib.auth.forms import UserCreationForm (this is deleted)
from django.shorcuts import render, redirect
from .forms import UserRegisterForm (see below)

def register(request):
	if request.method == 'POST':
		form = UserRegisterForm(request.POST)
		if form.is_valid():
		form.save()
			username = form.cleaned_data.get('username')
			messages.success(request, f'Account created for {username}')
			return redirect('blog-home')
	else:
		form = UserRegisterForm()
	return render(request, 'users/register.html', {'form': form})

flash messages, messages.debug, messages.info, messages.success, messages.warning, messages.error

include message on base.html, <div class="alert alert-{{ message.tags }}">, esto trae el tipo de mensaje como variable

create templates

folder templates/users

register.html

include path in project urls.py 

from users import views as user_views
path('regiter/', user_views.register, name='regiter')


add new fields to UserCreationForm

create a file in users app, forms.py

create a form that inherits from UserCreationForm

from django import forms
from django.contrib.auth.models import User
from django.contrib.auth.forms import UserCreationForm

class UserRegisterForm(UserCreationForm):
	email = forms.EmailField()

	class Meta:
		model = User
		fields = ['username', 'email', 'password1', 'password2']


Style of the form

use crispy forms

pip install django-crispy-forms

add to INSTALLED_APPS, 'crispy_forms'

add at the bottom of settings.py

CRISPY_TEMPLATE_PACK = 'bootstrap4'

add at the top of the template, after extends base html

{% load crispy_forms_tags %}

{{ form|crispy }}



Part 7

implement login, logout

project urls.py

from django.contrib.auth import views as auth_views

add path

path('login/', auth_views.LoginView.as_view(), name='login'),
path('logout/', auth_views.LogoutView.as_view(), name='logout'),

it looks for the template in registrations/login.html by default, it is changed to users/login.html

path('login/', auth_views.LoginView.as_view(template_name='users/login.html'), name='login'),
path('logout/', auth_views.LogoutView.as_view(template_name='users/logout.html'), name='logout'),

create login and logout templates

change login default redirect

LOGIN_REDIRECT_URL = 'blog-home'

change register view

def register(request):
	if request.method == 'POST':
		form = UserRegisterForm(request.POST)
		if form.is_valid():
		form.save()
			username = form.cleaned_data.get('username')
			messages.success(request, f'Your accoutn has been created, you are able to login')
			return redirect('login')
	else:
		form = UserRegisterForm()
	return render(request, 'users/register.html', {'form': form})

logout

the default logout redirects to the admin, this is just a demonstration

creates logout.html

conditionals to show nav bar links for logged users and not logged users

if user.is_authenticated

create profile view

def profile(request):
	return redirect(request, 'users/profile.html')

create profile html at users

create route in urls.py project

path('profile'/, user_views.profile, name='profile')

add decorator to profile view


from django.contrib.auth.decorators import login_required

change login route in settings

LOGIN_URL: 'login'

Part 8

add profile model

add model in models.py in users

from django.db import models
from django.contrib.auth.models import User

class Profile(models.Model):
	user = models.OneToOneField(User, on_delete=models.CASCADE)
	image = models.ImageField(default='default.jpg', upload_to='profile_pics')

	def __str__(self):
		return f'{self.user.username} Profile'

need install Pillow

pip install Pillow

make migrations, migrate

add model to the admin

he plays with queries in the shell

user.profile.image.width
user.profile.image.url

if there is a pic with same name it will create a hash

set media settings

MEDIA_ROOT = BASE_DIR / 'media'		//here django upload files on the file system
MEDIA_URL = '/media/'			//public directory, where we get the pic in the browser

now the pics go to media folder

profile.html (from snippets)

image tag: {{ user.profile.image.url }}

for development, add settings to project urls.py

from django.conf import settings
from django.conf.urls.static import static

if settings.DEBUG:
	urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

add default.jpg to media folder (this is the default place django looks for)

create profiles automatically

add django signal

in users app create a file called signals.py

from django.db.models.signals import post_save
from django.contrib.auth.models import User
from django.dispatch import receiver
from .models import Profile

@receiver(post_save, sender=User)
def create_profile(sender, instance, created, **kwargs):
	if created:
		Profile.objects.create(user=instance)

@receiver(post_save, sender=User)
def save_profile(sender, instance, **kwargs):
	instance.profile.save()

now, import signals inside

go to apps.py in users app

add...

	def ready(self):
		import users.signals

Part 9

Finish profile, update info, image resize

create forms

open forms.py in users

class UserUpdateForm(forms.ModelForm):
	email = forms.EmailField()

	class Meta:
		model = User
		fields = ['username', 'email']

the pic goes on the profile form

at the top add

from .models import Profile

add this form

class ProfileUpdateForm(forms.ModelForm):
	class Meta:
		model = Profile
		fields = ['image']

then go to views to add these forms to our profile view

from .forms import UserRegisterForm, UserUpdateForm, ProfileUpdateForm

add instances to profile view

def profile(request):
	u_form = UserUpdateForm()
	p_form = ProfileUpdateForm()

	context = {
		'u_form': u_form,
		'p_form': p_form
	}

	return render(request, 'users/profile.html', context)


I'm copying the form from register.html to put it on profile.html

		<form method="POST" enctype="multipart/form-data">
			{% csrf_token %}
			<fieldset class="form-group">
				<legend class="border-bottom mb-4">Profile Info</legend>
					{{ u_form|crispy }}
			{{ u_form|crispy }}
			</fieldset>
			<div class="form-group">
				<button class="btn btn-outline-info" type="submit">
					Update			   	 
				</button>
			</div>

		</form>



don't forget the enctype, whithout it the image won't work


populate fields
def profile(request):
	if request.method == 'POST':
		u_form = UserUpdateForm(request.POST, instance=request.user)
		p_form = ProfileUpdateForm(request.POST, request.FILES, instance=request.user.profile)
		if u_form.is_valid() and p_form.is_valid():
			u_form.save()
			p_form.save()
		messages.success(request, f'Your account has been updated')
		return redirect('profile')
	else:
		u_form = UserUpdateForm(instance=request.user)
		p_form = ProfileUpdateForm(instance=request.user.profile)

	context = {
		'u_form': u_form,
		'p_form': p_form
	}

	return render(request, 'users/profile.html', context)


We use Pillow to resize images

add to profile model the following

from PIL import Image

	def save(self):
		super().save()
		
		img = Image.open(self.image.path)
		
		if img.hight > 300 or img.width > 300:
			output_size = (300, 300)
			img.thumbnail(output_size)
			img.save(self.image.path)


Include user image on each blog

open home.html

after <article... tag include the following

<img class="rounded-circle article-img" src="{{ post.author.profile.image.url }}">


	
Part 10

add posts, class based views, 

in blog app open views.py

explanation about what are class based views

include at the top

from django.views.generic import ListView

write this below home view

class PostListView(ListView):
	model = Post
	
here is a try

add to views on the top

from .views import PostListView

change home view path as follows

path('', PostListView.as_view(), name='blog-home'),

so, with class based view django try to search for the template in <app>/<model>_<viewtype>.html

so we add to our class as follows

class PostListView(ListView):
	model = Post
	template_name = 'blog/home.html'
	context_object_name = 'posts'
	ordering = ['-date_posted']
	
by default in a ListView we get object_list, we need to set it up to change this name

UPDATE FROM HERE


Create a view for individual posts, a detail view

include after PostListView

class PostDetailView(DetailView):
	model = Post


open app urls

add

from .views... PostDetailView

add route

path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail'),

now create template, this time we are going to use the default name <app>/<model>_<viewtype>.html

create post_detail.html

{% extends "blog/base.html" %}

{% block content %}

	<article class="media content-section">
		<img class="rounded-circle article-img" src="{{ object.author.profile.image.url }}">
		<div class="media-body">
		<div class="article-metadata">
			<a class="mr-2" href="#">{{ object.author }}</a>
			<small class="text-muted">{{ object.date_posted|date:"F d, Y" }}</small>
		</div>
		<h2 class="article-title">{{ object.title }}</h2>
		<p class="article-content">{{ object.content }}</p>
		</div>
	</article>

{% endblock content %}



include links for post detail in home

href="{% url 'post-detail' post.id %}"

now let's do the create view

include CreateView in the headers on views.py

I can write it like this

from django.views.generic import (
	ListView, 
	DetailView,
	CreateView
)

class PostCreateView(CreateView):
	model = Post
	fields = ['title', 'content']
	
	
update urls.py

import PostCreateView,

add path

path('post/new/', PostCreateView.as_view(), name='post-create'),

in this case the name is different, is post_form.html, and will be shared with UpdateView

create template post_form.html

{% extends "blog/base.html" %}
{% load crispy_forms_tags %}

{% block content %}
    <div class="content-section">
        <form method="POST">
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottom mb-4">Blog Post</legend>
                    {{ form|crispy }}
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-info" type="submit">
                    Post
                </button>
            </div>

        </form>
    </div>
{% endblock content %}



if we try to add a post it won't work, we need to set the author of the post, need to override the form valid method for our create view, so we add the author before the form is submitted

go to views.py

in the PostCreateView add the following code

	def form_valid(self, form):
		form.instance.author = self.request.user
		return super().form_valid(form)
		
here still doesn't work, we need to set a place where to redirect

open blog models.py, we need to user reverse, no redirect

add at the top of models.py the following

from django.urls import reverse

add to the model the following

	def get_absolute_url(self):
		return reverse('post-detail', kwargs={'pk': self.pk})
		
if you would like to redirect to the home page, you could set an attribute on the create view called success url, and set that to the homepage



we need to restric create view to logged users, and we cannot use decorators with classes, we are going to use is a login mixin,

go to views

at the top

from django.contrib.auth.mixins import LoginRequiredMixin

then we include this in the arguments to the PostCreateView:

class PostCreateView(LoginRequiredMixin, CreateView):


Now create an update view

go to views

add import UpdateView in the headers

class PostUpdateView(LoginRequiredMixin, UpdateView):
	model = Post
	fields = ['title', 'content']

	def form_valid(self, form):
		form.instance.author = self.request.user
		return super().form_valid(form)



go to urls.py

add import PostUpdateView

add path

path('post/<int:pk>/update/', PostUpdateView.as_view(), name='post-update'),



need to restric who can update a post

go to views

add mixin, UserPassesTestMixin

add this to the arguments at the left of the view, as follows

class PostUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):

in the class ass the following code

	def test_func(self):
		post = self.get_object()
		if self.request.user == post.author:
			return True
		return False



delete view

go to views, import DeleteView

include Login mixin and UserPassesTestMixin

class PostDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):
	model = Post

	def test_func(self):
		post = self.get_object()
		if self.request.user == post.author:
			return True
		return False
		
add path to urls

import PostDeleteView

path('post/<int:pk>/delete/', PostDeleteView.as_view(), name='post-delete'),

the template, post_confirm_delete.html

{% extends "blog/base.html" %}

{% block content %}
    <div class="content-section">
        <form method="POST">
            {% csrf_token %}
            <fieldset class="form-group">
                <legend class="border-bottom mb-4">Delete Post</legend>
				<h2>Are you sure you want to delete the post "{{ object.title }}"</h2>
            </fieldset>
            <div class="form-group">
                <button class="btn btn-outline-danger" type="submit">
                    Yes, Delete
                </button>
				<a class="btn btn-outline-secondary" href="{% url 'post-detail' object.id %}">
                    Cancel
                </a>
            </div>
        </form>
    </div>
{% endblock content %}

we need to say where to redirect

go to views

after model = Post, add the following

	success_url = '/'

few changes at the side

open base.html

on top of <a class="nav-item nav-link" href="{% url 'profile' %}">Profile</a> add the following

<a class="nav-item nav-link" href="{% url 'post-create' %}">New Post</a>

open blog templates, post_detail.html, after author and date put the following

{% if object.author == user %}
	<div>
		<a class="btn btn-secondary btn-sm mt-1 mb-1" href="{% url 'post-update' object.id %}">Update</a>
		<a class="btn btn-danger btn-sm mt-1 mb-1" href="{% url 'post-delete' object.id %}">Delete</a>
	</div>
{% endif %}

Part 11

Pagination



copy file posts.json on root (already done)

open shell

import json

from blog.models import Post

with open('posts.json') as f:
	posts_json = json.load(f)
	
for post in posts_json:
	post = Post(title=post['title'], content=post['content'], author_id=post['user_id'])
	post.save()
	
exit()

UPDATE FROM HERE minuto 4

on shell

from django.core.paginator import Paginator

posts = ['1', '2', '3', '4', '5']

p = Paginator(posts, 2)

p.num_pages

for page in p.page_range:
	print(page)
	
p1 = p.page(1)

p1

p1.number

p1.object_list

p1.has_previous()

p1.has_next()

p1.next_page_number()

exit()

now go to views in blog, no need to import paginator with class based views, need to set an attribute

to class PostListView add the following

	paginate_by = 2
	

go to home.html

after for loop add the following

	{% if is_paginated %}
		{% if page_obj.has_previous %}
			<a class="btn btn-outline-info mb-4" href="?page=1">First</a>
			<a class="btn btn-outline-info mb-4" href="?page={{ page_obj.previous_page_number }}">Previous</a>
		{% endif %}
		{% for num in page_obj.paginator.page_range %}
			{% if page_obj.number == num %}
				<a class="btn btn-info mb-4" href="?page={{ num }}">{{ num }}</a>
			{% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}
				<a class="btn btn-outline-info mb-4" href="?page={{ num }}">{{ num }}</a>
			{% endif %}
		{% endfor %}
		{% if page_obj.has_next %}
			<a class="btn btn-outline-info mb-4" href="?page={{ page_obj.next_page_number }}">Next</a>
			<a class="btn btn-outline-info mb-4" href="?page={{ page_obj.paginator.num_pages }}">Last</a>
		{% endif %}
	{% endif %}
	
UPDATE FROM HERE

change number of posts per page to 5

do a route to go to the posts by an author with the link in the post

open views

from django.shorcuts import render, get_object_or_404
from django.contrib.auth.models import User

class UserPostListView(ListView):
	model = Post
	template_name = 'blog/user_posts.html'
	context_object_name = 'posts'
	ordering = ['-date_posted']
	paginate_by = 2
	
	def get_queryset(self):
		user = get_object_or_404(User, username=self.kwargs.get('username'))
		return Post.objects.filter(author=user).order_by('-date_posted')

need to add a filter to get posts from an user, this comes directly from the url , when we create a new url pattern for this we will specify the username and the url path itself, we'll set that with the url pattern, we will override a method called get_query_set

open urls.py, import UserPostListView
add path

path('user/<str:username>'/, UserPostListView.as_view(), name='user-posts'),

create the template, user_posts.html

{% extends "blog/base.html" %}

{% block content %}
	<h1 class="mb-3">Posts by {{ view.kwargs.username }} ({{ page_obj.paginator.count }})</h1>
    {% for post in posts %}
        <article class="media content-section">
            <img class="rounded-circle article-img" src="{{ post.author.profile.image.url }}">
            <div class="media-body">
            <div class="article-metadata">
                <a class="mr-2" href="{% url 'user-posts' post.author.username %}">{{ post.author }}</a>
                <small class="text-muted">{{ post.date_posted|date:"F d, Y" }}</small>
            </div>
            <h2><a class="article-title" href="{% url 'post-detail' post.id %}">{{ post.title }}</a></h2>
            <p class="article-content">{{ post.content }}</p>
            </div>
        </article>
    {% endfor %}
	{% if is_paginated %}
		{% if page_obj.has_previous %}
			<a class="btn btn-outline-info mb-4" href="?page=1">First</a>
			<a class="btn btn-outline-info mb-4" href="?page={{ page_obj.previous_page_number }}">Previous</a>
		{% endif %}
		{% for num in page_obj.paginator.page_range %}
			{% if page_obj.number == num %}
				<a class="btn btn-info mb-4" href="?page={{ num }}">{{ num }}</a>
			{% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}
				<a class="btn btn-outline-info mb-4" href="?page={{ num }}">{{ num }}</a>
			{% endif %}
		{% endfor %}
		{% if page_obj.has_next %}
			<a class="btn btn-outline-info mb-4" href="?page={{ page_obj.next_page_number }}">Next</a>
			<a class="btn btn-outline-info mb-4" href="?page={{ page_obj.paginator.num_pages }}">Last</a>
		{% endif %}
	{% endif %}
{% endblock content %}



the following link should be added to home.html and post_detail template

{% url 'user-posts' post.author.username %}

in post_detail change post by object, {% url 'user-posts' object.author.username %}









